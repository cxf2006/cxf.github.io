import{_ as p,o as e,c as r,b as o}from"./app-b63b8632.js";const a={},c=o('<h1 id="pmd如何运行" tabindex="-1"><a class="header-anchor" href="#pmd如何运行" aria-hidden="true">#</a> PMD如何运行</h1><p>Summary：PMD执行的不同步骤的处理概述。</p><h2 id="主要过程" tabindex="-1"><a class="header-anchor" href="#主要过程" aria-hidden="true">#</a> 主要过程</h2><p>​ 处理从主类PmdAnalysis开始处理。</p><p>​ 🍸解析命令行参数（参见net.sourceforge.pmd.cli.PMDParameters），还加载增量分析缓存文件。</p><p>​ 🍸加载规则集和规则。</p><p>​ 🍸确定语言（不同语言的规则可能混合在规则集中）。</p><p>​ 🍸确定文件（使用给定的源目录，按语言的文件扩展名进行过滤）</p><p>​ 🍸准备渲染器</p><p>​ 🍸按名称对文件进行排序</p><p>​ 🍸检查是否可以使用增量分析缓存（如果规则集发生变化，它将无效）</p><p>​ 🍸根据配置准备SourceCodeProcessor</p><p>​ 🍸分析文件。可以是单线程或多线程并行。此任务封装在net.sourceforge.pmd.processor.PMDRunnable中：</p><p>​ 🫓创建输入流</p><p>​ 🫓调用源码处理器(net.sourceforge.pmd.SourceCodeProcessor): ​ 🥩确定语言</p><p>​ 🥩检查文件是否已经分析过，是否可以从分析缓存中获取结果</p><p>​ 🥩解析源代码。结果是根AST节点。</p><p>​ 🥩始终运行SymbolFacade访问者。它构建作用域，找到声明和用法。</p><p>​ 🥩运行DFA（数据流分析）访问者（如果至少有一个规则需要它）以构建控制流图和数据流节点。</p><p>​ 🥩运行TypeResolution访问者（如果至少有一个规则需要它）</p><p>​ 🥩将来：运行多文件分析（如果至少有一个规则需要它）</p><p>​ 🥩执行规则：</p><p>​ 🍜首先运行选择了规则链机制的规则</p><p>​ 🍜运行所有其他规则并让它们遍历AST。规则可以使用符号表、类型解析信息和DFA节点。</p><p>​ 🍜规则将报告发现的问题作为规则违规。</p><p>​ 🍸将发现的违规行为呈现为所需的格式（XML、文本、HTML等）</p><p>​ 🍸存储增量分析缓存</p><p>​ 🍸根据发现的违规行为数量，退出时返回0或4。</p>',28),s=[c];function t(d,n){return e(),r("div",null,s)}const i=p(a,[["render",t],["__file","6PMD如何运行.html.vue"]]);export{i as default};
