import{_ as p,r as l,o as c,c as o,a,d as n,e,b as t}from"./app-1acd32cf.js";const i={},r=t(`<h1 id="pmd自定义规则介绍" tabindex="-1"><a class="header-anchor" href="#pmd自定义规则介绍" aria-hidden="true">#</a> PMD自定义规则介绍</h1><p>Summary: 制定自定义检测规则。</p><p>​ PMD是一个执行代码分析的框架。可以自定义检测规则以符合自己团队的代码风格。</p><h2 id="检测原理-ast" tabindex="-1"><a class="header-anchor" href="#检测原理-ast" aria-hidden="true">#</a> 检测原理：AST</h2><p>​ 在检测问题之前，PMD将源文件转化成叫抽象语法树（AST）的数据结构。AST有着代码的语句结构信息，代码的语法结构，并编码了源代码元素之间的语法关系。比较在Java中方法属于类，那么方向声明节点将是类声明节点的子节点。因此，这种表示方式比原始的源代码（对于一个程序来说，只是一串字符）或由词法分析器生成的标记链（例如，Checkstyle 所处理的内容）更加丰富。</p><p>​ 一个简单的java代码转成AST</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-AST line-numbers-mode" data-ext="AST"><pre class="language-AST"><code>└─ CompilationUnit
   └─ TypeDeclaration
      └─ ClassOrInterfaceDeclaration &quot;Foo&quot;
         ├─ ExtendsList
         │  └─ ClassOrInterfaceType &quot;Object&quot;
         └─ ClassOrInterfaceBody
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 从概念上讲，PMD 规则通过将一个“模式”与文件的抽象语法树（AST）进行匹配工作。规则会遍历AST并找到满足规则尝试标记的特定事物特征条件的节点。然后，规则会在这些节点上报告违规。</p><h2 id="了解ast" tabindex="-1"><a class="header-anchor" href="#了解ast" aria-hidden="true">#</a> 了解AST</h2><p>​ 抽象语法树（AST）由继承自 Node 的 Java 类表示。每种 PMD 语言都有一组这样的类，并根据语言的语法规则确定这些类如何相互关联。例如，所有的 Java AST 节点都继承自 JavaNode。</p><p>​ 可以通过以下方式来探索抽象语法树（AST）的结构：</p>`,12),u={href:"https://docs.pmd-code.org/latest/pmd_userdocs_extending_designer_reference.html#ast-inspection",target:"_blank",rel:"noopener noreferrer"},d={href:"https://docs.pmd-code.org/latest/pmd_devdocs_experimental_ast_dump.html",target:"_blank",rel:"noopener noreferrer"},v=t(`<h2 id="编写新的规则" tabindex="-1"><a class="header-anchor" href="#编写新的规则" aria-hidden="true">#</a> 编写新的规则</h2><p>​ PMD可以通过XPath query或者Java visitor这两种方式编写新的规则。XPath 规则更容易设置，因为它们直接在您的规则集XML中定义，并且足够表达几乎任何任务。</p><p>​ 另一方面，PMD API 的一些部分只能从Java中访问，例如访问声明的用法。而Java规则允许您进行一些复杂的处理，这是XPath规则无法扩展的。</p><p>​ 最终，选择其中一种策略取决于您的规则所涉及的难度。我建议除非没有其他选择，否则坚持使用XPath。</p><h2 id="xml规则定义" tabindex="-1"><a class="header-anchor" href="#xml规则定义" aria-hidden="true">#</a> XML规则定义</h2><p>​ 无论是使用XPath方式还是Java方式定义规则，在使用规则集之前需要在规则集中定义规则。这是就需要用到rule节点，但是此时不定义节点ref属性，自定义class属性。class属性指向实现该规则的类。</p><p>​ 对于Java规则：这个类需要继承AbstractRule。</p><p>​ 对于XPath规则：这个类就是net.sourceforge.pmd.lang.rule.XPathRule。</p><p>​ 例如：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rule</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>MyJavaRule<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>java<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">message</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Violation!<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.me.MyJavaRule<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>
        Description
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>priority</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>priority</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rule</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>🎗️在PMD7版本，新的rule节点都需要定义languge这个属性。某些基本规则类在其构造函数中隐含地设置了语言，因此并非所有情况都需要设置语言属性才能使规则正常工作。但是这种行为将在 PMD 7 中被停用，因此从 PMD 6.27.0 开始，如果缺少语言属性，将报告为前向兼容性警告。</p><h2 id="接下来的内容章节" tabindex="-1"><a class="header-anchor" href="#接下来的内容章节" aria-hidden="true">#</a> 接下来的内容章节</h2><p>学习如何写一个规则：</p><p>​ 《第一个规则》通过运行一个例子来介绍规则的基础开发。</p><p>​ 《XPath规则》详细说明XPath规则和XPath API。</p><p>​ 《Java规则》说明如何写一个java规则。</p><p>自定义规则进阶：</p><p>​ 《定义规则参数》说明如何通过rule节点的参数配置是的自定义规则变得可配置。</p><p>​ 《规则测试》介绍测试框架，以及如何使用这个框架来确保自定义规则的质量。</p>`,19);function h(m,k){const s=l("ExternalLinkIcon");return c(),o("div",null,[r,a("ul",null,[a("li",null,[n("the "),a("a",u,[n("规则设计器（Rule Designer）"),e(s)])]),a("li",null,[n("the "),a("a",d,[n("AST转储功能（AST dump feature）"),e(s)])])]),v])}const _=p(i,[["render",h],["__file","1自定义规则介绍.html.vue"]]);export{_ as default};
