import{_ as o,r as d,o as p,c as s,a,b as e,d as n,e as r}from"./app-d417e0ec.js";const h={},i=r(`<h1 id="路线图" tabindex="-1"><a class="header-anchor" href="#路线图" aria-hidden="true">#</a> 路线图</h1><h2 id="未来的方向" tabindex="-1"><a class="header-anchor" href="#未来的方向" aria-hidden="true">#</a> 未来的方向</h2><p>​ 想知道未来的计划是什么吗？或者更好的是，想要贡献吗？这是我们计划PMD未来方向的页面。它还为您提供了一些我们希望清理的代码部分的提示，您可以清理它们以贡献到项目中！</p><p>​ 当然，贡献的一种简单方法是查看bug跟踪器，看看是否可以修复一些问题 - 有些问题可能相当容易，我们只是没有时间查看它们！</p><p>​ 最后，如果您想贡献，请在pmd-devel邮件列表上注册，并与我们讨论！</p><h2 id="路线图-1" tabindex="-1"><a class="header-anchor" href="#路线图-1" aria-hidden="true">#</a> 路线图</h2><pre><code>此路线图包含PMD开发人员目前正在进行的各种“workshops”。
</code></pre><p>​ <strong>更好的符号分析</strong>：请参见下文。</p><p>​ <strong>数据流分析</strong>：请参见下文。</p><p>​ <strong>代码清理</strong>：请参见下文。</p><p>​ 请注意，当然，不能保证这些“特性”何时会完成，如果有可能的话。</p><h2 id="更好的符号分析" tabindex="-1"><a class="header-anchor" href="#更好的符号分析" aria-hidden="true">#</a> 更好的符号分析</h2><p>​ 目前，PMD一次只查看一个源文件。相反，它应该跨类解析符号。这将消除一些尚未解决的错误，并使更多规则能够编写。但是，这需要一些工作，因为它需要解析类文件。这里需要做很多工作。</p><h2 id="数据流分析-dfa" tabindex="-1"><a class="header-anchor" href="#数据流分析-dfa" aria-hidden="true">#</a> 数据流分析 (DFA)</h2>`,14),c={href:"http://www.fh-stralsund.de/",target:"_blank",rel:"noopener noreferrer"},l=r('<h2 id="我们希望看到的其他变化" tabindex="-1"><a class="header-anchor" href="#我们希望看到的其他变化" aria-hidden="true">#</a> 我们希望看到的其他变化…</h2><p>以下是真正应该完成的事情，但尚未完成的：</p><p>​ 🍸增强规则设计器，允许测试违规抑制的正则表达式和XPath。</p><p>​ 🍸删除特定类型解析的规则。将其合并回标准规则。一般情况下，规则应该在可能的情况下使用TR，否则使用非TR方法。不需要单独的TR/非TR规则。</p><p>​ 🍸协调util.designer和util.viewer包。这是相同内容的两个版本。Designer更为更新，但Viewer具有良好的MVC设计。</p><p>​ 🍸需要一个JUnit测试来检查“未使用”的规则，即没有被任何规则集使用的规则。</p><p>​ 🍸规则JUnit测试应验证测试类是否遵循预期的命名约定，就像规则需要的那样。</p><p>​ 🍸我们是否有一条规则来检查多个声明和链式赋值的样式？（例如，int a, b; int a = b = x;）</p><p>这些是值得思考的问题，也许是将来的项目。如果您认为您想要在其中一个上工作，请与pmd-devel咨询，以了解关于该主题的当前想法。</p><p>​ 🍸CPD在使用Language方面需要改进。它目前被硬编码为仅处理Java 1.4。在适当的情况下，将CPD需求整合到核心PMD中。否则，根据核心PMD驱动CPD行为，而不是重复一些逻辑。</p><p>​ 🍸需要一个更加灵活和强大的方案来将文件分类到不同的语言。至少，应该具备指定希望用于某种语言的文件扩展名的能力（例如，不是每个人都使用.jsp作为JSP扩展名，有些人使用.jsx、.xhtml等）。此外，考虑在LanguageVersionDiscoverer过程中提供用于将文件/字符串分类到特定语言的LanguageVersion的钩子，可以使用类似Unix使用的“魔法”系统来根据实际内容区分不同版本的文件。</p><p>​ 🍸我们是否应该将Node接口更改为类似于&#39;Node&lt;T extends Node&lt;T&gt;&gt;&#39;的形式，然后声明语言特定的节点接口为类似于&#39;JavaNode extends Node&lt;JavaNode&gt;&#39;的形式？这可以允许Node接口上的任何内容返回语言特定的节点类型，而不是通用节点。例如，ASTStatement.jjtGetParent()可以返回一个JavaNode，而不是一个Node。这是一个相当大的改变，因为Node接口是PMD代码库中普遍存在的东西之一。在使用Node接口与泛型时额外的工作是否值得遏制偶尔的强制转换？</p><p>​ 🍸多个语言是否能够声明对单个源文件的支持？想象一下XML格式的JSP文件，你已经定义了一个使用JSP和XML规则的规则集。说明某些XML规则也适用于JSP语言扩展可能会很有用。这意味着源文件到语言版本的映射不是一对一的，而是一对多的关系，我们需要相应地处理这个情况。</p>',13),u={href:"http://sourceforge.net/p/pmd/discussion/188194/thread/b840897c",target:"_blank",rel:"noopener noreferrer"},_=r('<p>​ 🍸找到一种允许规则处理括号和代码块的方法，这些结构引入了某些重复的（通常对大多数规则来说是可以忽略的）AST树。一些规则正在做特殊的工作（例如混淆三元规则）来检测这些AST模式。也许可以创建一个“标准化”的AST结构，使AST看起来一致，无论有多少括号或代码块（例如，插入默认代码块，折叠重复的代码块）。这应该可以像TR和SymbolTable一样以每个规则的方式进行配置。</p><h2 id="代码清理" tabindex="-1"><a class="header-anchor" href="#代码清理" aria-hidden="true">#</a> 代码清理</h2><p>一些代码有点混乱：</p><p>​ 🍸RuleSetFactory有点混乱。需要重构为具有层次结构、装饰器或其他内容的东西。</p><p>​ 🍸ConstructorCallsOverridableMethod和DoubleCheckedLocking的清理将是受欢迎的。</p><p>​ 🍸Designer GUI有点混乱；底部窗格看起来有点奇怪。</p><p>​ 语法有一些奇怪的地方：</p><p>​ 🍸BlockStatement中有一个用于方法内部的类定义的奇怪小技巧。</p><p>​ 🍸enumLookahead()似乎有点过度，是否可以以某种方式使用Modifiers？</p><p>​ 🍸 整个“discardable node”似乎很浪费。</p><p>​ 🍸ExtendsList需要那个‘extendsMoreThanOne’吗？</p><p>​ 🍸ClassOrInterfaceBodyDeclaration需要一个庞大的前瞻来检查枚举。</p><p>​ 🍸ClassOrInterfaceType将点分隔的名称混合在一起... 这是正确的做法吗？</p><p>​ 🍸一些复杂的注释目前存在问题。</p>',14);function f(g,x){const t=d("ExternalLinkIcon");return p(),s("div",null,[i,a("p",null,[e("​ "),a("a",c,[e("Fachhochschule Stralsund"),n(t)]),e("的研究生Raik Schroeder编写了一个DFA层，这应该使我们能够编写一些更复杂的规则 - 像公共子表达式消除、循环不变代码移动（和代码提取建议）、缩小包装和部分冗余消除等规则。该代码目前位于net.sourceforge.pmd.dfa包中，我们正在研究如何编写使用它的规则。我们应该能够使用它来简化一些当前的规则。")]),l,a("p",null,[e("​ 🍸在子"),a("a",u,[e("这个论坛帖"),n(t)]),e("中讨论的规则集内的规则组织的其他更改。")]),_])}const m=o(h,[["render",f],["__file","5路线图.html.vue"]]);export{m as default};
