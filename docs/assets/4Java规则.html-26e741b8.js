import{_ as t,r as o,o as l,c,a as n,b as e,d as s,e as r}from"./app-d417e0ec.js";const i={},p=n("h1",{id:"写一个定制的规则",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#写一个定制的规则","aria-hidden":"true"},"#"),e(" 写一个定制的规则")],-1),d=n("p",null,"Summary:学习如何写一个PMD的定制规则。",-1),u=n("p",null,"🎗️这一切应该写在Javadocs中，甚至不确定我们是否需要一个文档页面。这也更容易维护。",-1),h=n("p",null,"⚠️工作正在进行中，目前此文档不完善。",-1),m=n("p",null,"​ 本节涵盖了在Java中编写规则的具体内容。基本的开发流程与XPath规则的开发流程非常相似，XPath规则的开发流程在“第一个规则”中有描述。",-1),_=n("p",null,"​ 基本步骤，打开规则设计器，查看AST的结构，并随着添加测试案例不断完善您的规则。",-1),v=n("p",null,"​ 本节内容只针对java语言的规则进行讲解,其他语言与这个类似.",-1),k={href:"https://docs.pmd-code.org/latest/tag_languages.html",target:"_blank",rel:"noopener noreferrer"},b=n("h2",{id:"基础",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#基础","aria-hidden":"true"},"#"),e(" 基础")],-1),f=n("p",null,"​ 要在Java中编写规则，您需要：",-1),g=n("ol",null,[n("li",null,"编写一个实现Rule接口的Java类。每种语言的实现都提供了一个基本规则类，以简化您的工作，例如AbstractJavaRule。"),n("li",null,"编译此类，并将其链接到PMD的API（例如，使用PMD作为Maven依赖）。"),n("li",null,"打包这个类成一个JAR文件，并将其添加到PMD的执行类路径中。"),n("li",null,"在您的规则集XML中声明这个规则。")],-1),x=n("h2",{id:"规则执行",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#规则执行","aria-hidden":"true"},"#"),e(" 规则执行")],-1),y={href:"https://sourcemaking.com/design_patterns/visitor",target:"_blank",rel:"noopener noreferrer"},R=r(`<h3 id="树遍历" tabindex="-1"><a class="header-anchor" href="#树遍历" aria-hidden="true">#</a> 树遍历</h3><p>​ 当将规则应用于文件时，它会传递AST的根节点，并被告知遍历整个树以查找违规。每个规则为语言的每种节点类型定义了特定的访问方法，默认情况下仅访问子节点。</p><p>​ 因此，以下规则将遍历整个树并不执行任何操作：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRule</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractJavaRule</span> <span class="token punctuation">{</span>
    <span class="token comment">// all methods are default implementations!</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 通常，规则只想检查某些节点类型。在我们在&quot;Your First Rule&quot;中的XPath示例中，我们想要检查一些VariableDeclaratorId节点。这是XPath的名称，但在Java中，您可以通过ASTVariableDeclaratorId类的方法获取想要的数据。</p><p>​ 如果想要进行一些特殊的处理，重写visit方法即可。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRule</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractJavaRule</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">ASTVariableDeclaratorId</span> node<span class="token punctuation">,</span> <span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// This method is called on each node of type ASTVariableDeclaratorId</span>
        <span class="token comment">// in the AST</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">short</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// reports a violation at the position of the node</span>
            <span class="token comment">// the &quot;data&quot; parameter is a context object handed to by your rule</span>
            <span class="token comment">// the message for the violation is the message defined in the rule declaration XML element</span>
            <span class="token function">addViolation</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// this calls back to the default implementation, which recurses further down the subtree</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 最后需要调用super.visit(node, data)方法以使遍历继续。</p><h3 id="停止遍历" tabindex="-1"><a class="header-anchor" href="#停止遍历" aria-hidden="true">#</a> 停止遍历</h3><p>​ 如果你在检查完某个节点后不想再遍历其子节点，可以不调用super.visit方法，此时该节点的子节点将不再被遍历，但是兄弟节点还是被被遍历。</p><h3 id="快速遍历-规则链" tabindex="-1"><a class="header-anchor" href="#快速遍历-规则链" aria-hidden="true">#</a> 快速遍历：规则链</h3><p>​ 如果您不关心节点的遍历顺序（例如，您的规则在访问之间不维护任何状态），那么您可以通过使用规则链来大大加快规则的速度。</p><p>​ 这种机制不会对整个树进行递归，而是只会传递您感兴趣的节点给您的规则。要正确使用规则链：</p><ol><li>您的规则必须在其构造函数中调用<code>addRuleChainVisit</code>来注册那些节点类型。</li><li>您的访问方法不应递归！实际上，在方法中不应该调用<code>super.visit</code>。</li></ol><h3 id="跨文件执行-线程安全和状态性" tabindex="-1"><a class="header-anchor" href="#跨文件执行-线程安全和状态性" aria-hidden="true">#</a> 跨文件执行，线程安全和状态性</h3><p>​ 在开始执行时，PMD将实例化新的规则实例。如果PMD在多个线程中执行，那么每个线程都使用自己的规则实例。这意味着规则实现不需要关心线程问题，因为PMD确保同一个实例用在多个线程中。</p><p>​ 然而，出于性能原因，规则实例用于多个文件。这意味着规则的构造函数只执行一次（每个线程一次），并且规则实例会被重用。如果您依赖于实例属性的正确初始化，您可以在ASTCompilationUnit节点的visit方法中进行初始化，该节点首先访问每个文件并且只执行一次。不过，这种解决方法仅适用于针对Java语言编写的规则。一种与语言无关的方法是覆盖规则的<code>start</code>方法，<code>start</code>方法在每个文件中只调用一次。</p><h2 id="规则生命周期" tabindex="-1"><a class="header-anchor" href="#规则生命周期" aria-hidden="true">#</a> 规则生命周期</h2><h3 id="构建" tabindex="-1"><a class="header-anchor" href="#构建" aria-hidden="true">#</a> 构建</h3><pre><code>以下步骤只执行一次：
</code></pre><p>​ 1.当加载规则集时，调用规则的无参构造函数。规则的构造函数必须定义：</p>`,21),w={href:"https://docs.pmd-code.org/latest/pmd_userdocs_extending_writing_java_rules.html#economic-traversal-the-rulechain",target:"_blank",rel:"noopener noreferrer"},A={href:"https://docs.pmd-code.org/latest/pmd_userdocs_extending_defining_properties.html#for-java-rules",target:"_blank",rel:"noopener noreferrer"},j={href:"https://docs.pmd-code.org/latest/pmd_userdocs_configuring_rules.html#rule-properties",target:"_blank",rel:"noopener noreferrer"},T=n("p",null,"​ 3.配置错误的规则将从规则集中移除。",-1),J=n("h3",{id:"执行",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#执行","aria-hidden":"true"},"#"),e(" 执行")],-1),M=n("pre",null,[n("code",null,`对于每个线程，都会创建规则的深拷贝。每个线程都会获得一组不同的要分析的文件。然后，对于每个这样的文件，对于每个规则副本：
`)],-1),P={href:"https://docs.pmd-code.org/apidocs/pmd-core/7.0.0-rc4/net/sourceforge/pmd/Rule.html#start(net.sourceforge.pmd.RuleContext)",target:"_blank",rel:"noopener noreferrer"},S=n("code",null,"start",-1),D={href:"https://docs.pmd-code.org/apidocs/pmd-core/7.0.0-rc4/net/sourceforge/pmd/Rule.html#apply(java.util.List,net.sourceforge.pmd.RuleContext)",target:"_blank",rel:"noopener noreferrer"},V=n("code",null,"apply",-1),C=n("code",null,"。该方法执行AST遍历，最终调用访问方法。对于",-1),I=n("code",null,"规则，不会调用",-1),X={href:"https://docs.pmd-code.org/apidocs/pmd-core/7.0.0-rc4/net/sourceforge/pmd/Rule.html#end(net.sourceforge.pmd.RuleContext)",target:"_blank",rel:"noopener noreferrer"},L=n("code",null,"end",-1);function q(N,B){const a=o("ExternalLinkIcon");return l(),c("div",null,[p,d,u,h,m,_,v,n("p",null,[e("🎗️"),n("a",k,[e("这里可以不同语言的帮助文档"),s(a)])]),b,f,g,x,n("p",null,[e("​ 大多数基本规则类使用 "),n("a",y,[e("访问者模式"),s(a)]),e("来遍历AST。")]),R,n("p",null,[e("​ 📍"),n("a",w,[e("规则链访问"),s(a)])]),n("p",null,[e("​ 📍 "),n("a",A,[e("属性描述符"),s(a)])]),n("p",null,[e("​ 2.如果规则作为规则引用包含在规则集中，某些属性"),n("a",j,[e("可能会被覆盖"),s(a)]),e("。如果覆盖的属性未知，将报告错误。")]),T,J,M,n("p",null,[e("​ 📍在解析之前，会调用一次"),n("a",P,[S,s(a)]),e("。")]),n("p",null,[e("​ 📍使用AST的根节点调用"),n("a",D,[V,s(a)]),C,e("RuleChain"),I,e("apply`。")]),n("p",null,[e("​ 📍当规则完成文件处理时，会调用"),n("a",X,[L,s(a)]),e("。")])])}const O=t(i,[["render",q],["__file","4Java规则.html.vue"]]);export{O as default};
