import{_ as r,r as n,o as i,c as d,a as e,d as t,e as s,b as o}from"./app-26a5a8f2.js";const l={},c=o(`<h1 id="为基于-javacc-语法的新语言添加-pmd-支持" tabindex="-1"><a class="header-anchor" href="#为基于-javacc-语法的新语言添加-pmd-支持" aria-hidden="true">#</a> 为基于 JavaCC 语法的新语言添加 PMD 支持</h1><p>Summary:如何使用 JavaCC 语法将新语言添加到 PMD。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>开始之前请阅读:
这确实是一个重大的贡献，不能仅仅凭一时的兴致来完成。它需要专注的热情和长期的承诺，以实现对新语言的支持。

这个逐步指南只是一个入门，用来开始了解基础，而且也不一定是最新或完整的。你必须有能力填补缺漏。

在为一种语言提供基本支持后，仍然有许多缺失的功能。可以极大改进规则编写的典型功能包括：符号表、类型解析、调用/数据流分析。

符号表跟踪变量及其使用情况。类型解析试图找到每个使用的类型的实际类类型，跟随方法调用（包括重载和覆盖的方法），允许查询子类型和类型层次结构。这需要对辅助类路径进行额外配置。调用和数据流分析跟踪数据在程序的不同执行路径中的流动。

这些功能超出了本指南的范围。类型解析和数据流是绝对不是免费的功能。它需要很大的努力和毅力来实现。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤</h2><h3 id="_1-从一个新的子模块开始" tabindex="-1"><a class="header-anchor" href="#_1-从一个新的子模块开始" aria-hidden="true">#</a> 1.从一个新的子模块开始</h3><p>​ 🍸参考 pmd-java 或 pmd-vm 以获取示例。</p><p>​ 🍸确保将新模块添加到 PMD 的父 POM 中作为 <code>&lt;module&gt;</code> 条目，以便它与其他语言一起构建。</p><p>​ 🍸还需要将新模块添加到“pmd-languages-deps/pom.xml”的依赖列表中，以便新语言自动包含在二进制分发（pmd-dist）中。</p><h3 id="_2-为你的语言实现一个ast解析器" tabindex="-1"><a class="header-anchor" href="#_2-为你的语言实现一个ast解析器" aria-hidden="true">#</a> 2.为你的语言实现一个AST解析器</h3><p>​ 🍸理想情况下，AST解析器应该作为一个JJT文件实现（参考VmParser.jjt或Java.jjt作为示例）。</p><p>​ 🍸当然，也可以使用其他解析器实现，只要你有一种将输入流转换为AST树的方法。使用JJT方式简化了以后的维护工作。</p><p>​ 🍸参考此链接以获取更多信息：https://javacc.java.net/doc/JJTree.html</p><h3 id="_3-创建ast节点类" tabindex="-1"><a class="header-anchor" href="#_3-创建ast节点类" aria-hidden="true">#</a> 3.创建AST节点类</h3><p>​ 🍸对于解析器生成的每个AST节点，都应该有一个类。</p><p>​ 🍸AST类的名称应该是“AST” + JJT文件中节点的名称。</p><p>​ 🫓例如，如果JJT包含一个名为“IfStatement”的节点，那么应该有一个名为“ASTIfStatement”的类。</p><p>​ 🍸每个AST类应该有一个包私有的构造函数，接受一个整数id作为参数。</p><p>​ 🍸创建一个针对语言的所有AST类的父类是一个好主意，这样可以简化后续的规则创建（例如，参考Velocity的SimpleNode和Java的AbstractJavaNode）。</p><p>​ 🍸 注意：这些AST节点类通常是由javacc/jjtree生成的，然后根据需要进行修改。</p><h3 id="_4-生成你的解析器-使用jjt" tabindex="-1"><a class="header-anchor" href="#_4-生成你的解析器-使用jjt" aria-hidden="true">#</a> 4.生成你的解析器（使用JJT）</h3><p>​ 🍸 使用Ant脚本将jjt文件编译成类。这个脚本位于PMD顶级源代码中的javacc-wrapper.xml文件中。</p><p>​ 🍸 通过maven-antrun-plugin执行这个Ant脚本。将这个插件添加到你的pom.xml文件中，并配置它的语言名称。你可以使用pmd-java/pom.xml作为示例。</p><p>​ 🍸 这个Ant脚本在整个项目构建时的generate-sources阶段被调用。但如果你希望生成你的解析器，也可以直接在你的模块中使用<code>./mvnw generate-sources</code>来调用它。</p><h3 id="_5-创建一个pmd解析器-适配器" tabindex="-1"><a class="header-anchor" href="#_5-创建一个pmd解析器-适配器" aria-hidden="true">#</a> 5.创建一个PMD解析器 &quot;适配器&quot;</h3><p>​ 🍸创建一个新的类，它扩展了JjtreeParserAdapter。</p><p>​ 🍸这是一个通用的类，你需要声明根AST节点。</p><p>​ 🍸有两个重要的方法需要实现。</p><p>​ 🫓<code>tokenBehavior</code> 方法应该返回一个使用你的语言中的令牌列表构建的TokenDocumentBehavior的新实例。在编译步骤 #4 中，将生成一个名为 <code>$langTokenKinds</code> 的类，其中包含所有可用的令牌在字段 <code>TOKEN_NAMES</code> 中。</p><p>​ 🫓<code>parseImpl</code> 方法应该返回通过解析CharStream源获取的AST树的根节点。</p><p>​ 🫓可以参考VmParser类作为示例。</p>`,30),u={id:"_6-create-a-language-version-handler-✏️️",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#_6-create-a-language-version-handler-✏️️","aria-hidden":"true"},"#",-1),p={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},m=o("<ul><li>Extend <code>AbstractPmdLanguageVersionHandler</code> <em>(see VmHandler for example)</em></li><li>This class is sort of a gateway between PMD and all parsing logic specific to your language.</li><li>For a minimal implementation, it just needs to return a parser <em>(see step #5)</em>.</li><li>It can be used to provide other features for your language like <ul><li>violation suppression logic</li><li>violation decorators, to add additional language specific information to the created violations</li><li>metrics (see below “Optional features”)</li><li>custom XPath functions</li></ul></li><li>See <code>VmHandler</code> class as an example</li></ul>",1),g={id:"_7-create-a-base-visitor-✏️️",tabindex:"-1"},_=e("a",{class:"header-anchor",href:"#_7-create-a-base-visitor-✏️️","aria-hidden":"true"},"#",-1),f={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},b=e("li",null,"A parser visitor adapter is not needed anymore with PMD 7. The visitor interface now provides a default implementation.",-1),v={href:"https://github.com/pmd/pmd/blob/pmd/7.0.x/pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/AstVisitor.java",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"AstVisitor",-1),T=e("li",null,[t("The generated visitor class for VM is called "),e("code",null,"VmVisitor"),t(".")],-1),y=e("li",null,[t("In order to help use this visitor later on, a base visitor class should be created. See "),e("code",null,"VmVisitorBase"),t(" as an example.")],-1),j={id:"_8-make-pmd-recognize-your-language-✏️️",tabindex:"-1"},A=e("a",{class:"header-anchor",href:"#_8-make-pmd-recognize-your-language-✏️️","aria-hidden":"true"},"#",-1),w={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},S=o("<ul><li>Create your own subclass of <code>net.sourceforge.pmd.lang.impl.SimpleLanguageModuleBase</code>. <em>(see VmLanguageModule or JavaLanguageModule as an example)</em></li><li>Add for each version of your language a call to <code>addVersion</code> in your language module’s constructor. Use <code>addDefaultVersion</code> for defining the default version.</li><li>You’ll need to refer the language version handler created in step #6.</li><li>Create the service registration via the text file <code>src/main/resources/META-INF/services/net.sourceforge.pmd.lang.Language</code>. Add your fully qualified class name as a single line into it.</li></ul>",1),k={id:"_9-add-ast-regression-tests-✏️️",tabindex:"-1"},P=e("a",{class:"header-anchor",href:"#_9-add-ast-regression-tests-✏️️","aria-hidden":"true"},"#",-1),J={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},M=o(`<p>For languages, that use an external library for parsing, the AST can easily change when upgrading the library. Also for languages, where we have the grammar under our control, it is useful to have such tests.</p><p>The tests parse one or more source files and generate a textual representation of the AST. This text is compared against a previously recorded version. If there are differences, the test fails.</p><p>This helps to detect anything in the AST structure that changed, maybe unexpectedly.</p><ul><li><p>Create a test class in the package <code>net.sourceforge.pmd.lang.$lang.ast</code> with the name <code>$langTreeDumpTest</code>.</p></li><li><p>This test class must extend <code>net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest</code>. Note: This class is written in kotlin and is available in the module “lang-test”.</p></li><li><p>Add a default constructor, that calls the super constructor like so:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    public $langTreeDumpTest() {
        super(NodePrintersKt.getSimpleNodePrinter(), &quot;.$extension&quot;);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Replace “$lang” and “$extension” accordingly.</p></li><li><p>Implement the method <code>getParser()</code>. It must return a subclass of <code>net.sourceforge.pmd.lang.ast.test.BaseParsingHelper</code>. See <code>net.sourceforge.pmd.lang.ecmascript.ast.JsParsingHelper</code> for an example. With this parser helper you can also specify, where the test files are searched, by using the method <code>withResourceContext(Class&lt;?&gt;, String)</code>.</p></li><li><p>Add one or more test methods. Each test method parses one file and compares the result. The base class has a helper method <code>doTest(String)</code> that does all the work. This method just needs to be called:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    @Test
    public void myFirstAstTest() {
        doTest(&quot;filename-without-extension&quot;);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>On the first test run the test fails. A text file (with the extension <code>.txt</code>) is created, that records the current AST. On the next run, the text file is used as comparison and the test should pass. Don’t forget to commit the generated text file.</p></li></ul><p>A complete example can be seen in the JavaScript module: <code>net.sourceforge.pmd.lang.ecmascript.ast.JsTreeDumpTest</code>. The test resources are in the subpackage “testdata”: <code>pmd-javascript/src/test/resources/net/sourceforge/pmd/lang/ecmascript/ast/testdata/</code>.</p><p>The Scala module also has a test, written in Kotlin instead of Java: <code>net.sourceforge.pmd.lang.scala.ast.ScalaParserTests</code>.</p>`,6),C={id:"_10-create-an-abstract-rule-class-for-the-language-✏️️",tabindex:"-1"},D=e("a",{class:"header-anchor",href:"#_10-create-an-abstract-rule-class-for-the-language-✏️️","aria-hidden":"true"},"#",-1),V={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},N=e("ul",null,[e("li",null,[t("Extend "),e("code",null,"AbstractRule"),t(" and implement the parser visitor interface for your language "),e("em",null,"(see AbstractVmRule for example)")]),e("li",null,"All other rules for your language should extend this class. The purpose of this class is to implement visit methods for all AST types to simply delegate to default behavior. This is useful because most rules care only about specific AST nodes, but PMD needs to know what to do with each node - so this just lets you use default behavior for nodes you don’t care about.")],-1),R={id:"_11-create-rules-✏️️",tabindex:"-1"},I=e("a",{class:"header-anchor",href:"#_11-create-rules-✏️️","aria-hidden":"true"},"#",-1),L={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},E=e("ul",null,[e("li",null,[t("Rules are created by extending the abstract rule class created in step 9 "),e("em",null,[t("(see "),e("code",null,"EmptyForeachStmtRule"),t(" for example)")])]),e("li",null,"Creating rules is already pretty well documented in PMD - and it’s no different for a new language, except you may have different AST nodes.")],-1),B={id:"_12-test-the-rules-✏️️",tabindex:"-1"},q=e("a",{class:"header-anchor",href:"#_12-test-the-rules-✏️️","aria-hidden":"true"},"#",-1),O={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},F=o("<ul><li><p>Testing rules is described in depth in</p><p>Testing your rules</p><p>.</p><ul><li>Each rule has its own test class: Create a test class for your rule extending <code>PmdRuleTst</code> <em>(see AvoidReassigningParametersTest in pmd-vm for example)</em></li><li>Create a category rule set for your language <em>(see category/vm/bestpractices.xml for example)</em></li><li>Place the test XML file with the test cases in the correct location</li><li>When executing the test class <ul><li>this triggers the unit test to read the corresponding XML file with the rule test data <em>(see <code>AvoidReassigningParameters.xml</code> for example)</em></li><li>This test XML file contains sample pieces of code which should trigger a specified number of violations of this rule. The unit test will execute the rule on this piece of code, and verify that the number of violations matches.</li></ul></li></ul></li><li><p>To verify the validity of the created ruleset, create a subclass of <code>AbstractRuleSetFactoryTest</code> (<em>see <code>RuleSetFactoryTest</code> in pmd-vm for example)</em>. This will load all rulesets and verify, that all required attributes are provided.</p><p><em>Note:</em> You’ll need to add your category ruleset to <code>categories.properties</code>, so that it can be found.</p></li></ul>",1),H={id:"debugging-with-rule-designer-✏️️",tabindex:"-1"},$=e("a",{class:"header-anchor",href:"#debugging-with-rule-designer-✏️️","aria-hidden":"true"},"#",-1),X={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},K=e("p",null,"When implementing your grammar it may be very useful to see how PMD parses your example files. This can be achieved with Rule Designer:",-1),z=e("li",null,[e("p",null,[t("Override the "),e("code",null,"getXPathNodeName"),t(" in your AST nodes for Designer to show node names.")])],-1),W=e("li",null,[e("p",null,[t("Make sure to override both "),e("code",null,"jjtOpen"),t(" and "),e("code",null,"jjtClose"),t(" in your AST node base class so that they set both start and end line and column for proper node bound highlighting.")])],-1),Y=e("p",null,"Not strictly required but trivial and useful:",-1),U=e("p",null,"implement syntax highlighting for Rule Designer:",-1),G={href:"https://github.com/pmd/pmd-designer",target:"_blank",rel:"noopener noreferrer"},Q=o("<li>Add a syntax highlighter implementation to <code>net.sourceforge.pmd.util.fxdesigner.util.codearea.syntaxhighlighting</code> (you could use Java as an example).</li><li>Register it in the <code>AvailableSyntaxHighlighters</code> enumeration.</li><li>Now build your implementation and place the <code>target/pmd-ui-&lt;version&gt;-SNAPSHOT.jar</code> to the <code>lib</code> directory inside your <code>pmd-bin-...</code> distribution (you have to delete old <code>pmd-ui-*.jar</code> from there).</li>",3),Z={id:"optional-features-✏️️",tabindex:"-1"},ee=e("a",{class:"header-anchor",href:"#optional-features-✏️️","aria-hidden":"true"},"#",-1),te={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},ae={id:"metrics-✏️️",tabindex:"-1"},se=e("a",{class:"header-anchor",href:"#metrics-✏️️","aria-hidden":"true"},"#",-1),oe={href:"https://github.com/pmd/pmd/blob/master/docs/pages/pmd/devdocs/major_contributions/adding_a_new_javacc_based_language.md",target:"_blank",rel:"noopener noreferrer"},re=e("p",null,"If you want to add support for computing metrics:",-1),ne=e("li",null,[t("Create a package "),e("code",null,"lang.<langname>.metrics")],-1),ie=e("li",null,[t("Create a utility class "),e("code",null,"<langname>Metrics")],-1),de=e("li",null,"Implement new metrics and add them as static constants. Be sure to document them.",-1),le={href:"https://docs.pmd-code.org/apidocs/pmd-core/7.0.0-rc4/net/sourceforge/pmd/lang/LanguageVersionHandler.html#getLanguageMetricsProvider()",target:"_blank",rel:"noopener noreferrer"},ce=e("code",null,"getLanguageMetricsProvider",-1),ue={href:"https://docs.pmd-code.org/apidocs/pmd-java/7.0.0-rc4/net/sourceforge/pmd/lang/java/metrics/JavaMetrics.html#",target:"_blank",rel:"noopener noreferrer"},he=e("code",null,"JavaMetrics",-1);function pe(me,ge){const a=n("ExternalLinkIcon");return i(),d("div",null,[c,e("h3",u,[h,t(" 6. Create a language version handler "),e("a",p,[t("✏️️"),s(a)])]),m,e("h3",g,[_,t(" 7. Create a base visitor "),e("a",f,[t("✏️️"),s(a)])]),e("ul",null,[b,e("li",null,[t("The visitor for JavaCC based AST is generated along the parser from the grammar file. The base interface for a visitor is "),e("a",v,[x,s(a)]),t(".")]),T,y]),e("h3",j,[A,t(" 8. Make PMD recognize your language "),e("a",w,[t("✏️️"),s(a)])]),S,e("h3",k,[P,t(" 9. Add AST regression tests "),e("a",J,[t("✏️️"),s(a)])]),M,e("h3",C,[D,t(" 10. Create an abstract rule class for the language "),e("a",V,[t("✏️️"),s(a)])]),N,e("h3",R,[I,t(" 11. Create rules "),e("a",L,[t("✏️️"),s(a)])]),E,e("h3",B,[q,t(" 12. Test the rules "),e("a",O,[t("✏️️"),s(a)])]),F,e("h2",H,[$,t(" Debugging with Rule Designer "),e("a",X,[t("✏️️"),s(a)])]),K,e("ul",null,[z,W,e("li",null,[Y,U,e("ul",null,[e("li",null,[t("Fork and clone the "),e("a",G,[t("pmd/pmd-designer"),s(a)]),t(" repository.")]),Q])])]),e("h2",Z,[ee,t(" Optional features "),e("a",te,[t("✏️️"),s(a)])]),e("h3",ae,[se,t(" Metrics "),e("a",oe,[t("✏️️"),s(a)])]),re,e("ul",null,[ne,ie,de,e("li",null,[t("Implement "),e("a",le,[ce,s(a)]),t(", to make the metrics available in the designer.")])]),e("p",null,[t("See "),e("a",ue,[he,s(a)]),t(" for an example.")])])}const fe=r(l,[["render",pe],["__file","2支持新语言(JavaCC).html.vue"]]);export{fe as default};
