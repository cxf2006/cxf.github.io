import{_ as s,r as p,o as d,c as t,a as e,d as a,e as r,b as c}from"./app-b63b8632.js";const n={},o=c('<h1 id="增量分析" tabindex="-1"><a class="header-anchor" href="#增量分析" aria-hidden="true">#</a> 增量分析</h1><p>摘要：解析如果使用增量分析以加快分析速度。</p><p>该功能需要PMD的版本大于等于5.6.0。</p><p>​ 当执行增量分析时，PMD会缓存分析数据和结果，用于后面检测文件是否修改或增加。一个典型的应用场景就是当你只修改了少量文件时，将大大减少分析时间。</p><p>​ 增量检测和全量检测输出的报告内容是一致的。最终报告中的文件和实际存在的文件一致。即使未需改的文件中的问题也会一起报告。强烈使用这种方式进行检测。</p><h2 id="开启增量检测" tabindex="-1"><a class="header-anchor" href="#开启增量检测" aria-hidden="true">#</a> 开启增量检测</h2><p>​ 增量分析会随着缓存位置的配置而自动开启。在命令行方式中可以使用“--cache”参数配置缓存位置，但是只在继承了PMD的Ant，Maven，Gradle中支持该特性。</p><h2 id="关闭增量检测" tabindex="-1"><a class="header-anchor" href="#关闭增量检测" aria-hidden="true">#</a> 关闭增量检测</h2><p>​ 默认情况下，如果没开启增加分析，PMD会在日志中输入告警提示开启增加检测。如果想要关闭告警和增量检测可以使用-no-cache参数来关闭。</p><h2 id="增量分析常见问题" tabindex="-1"><a class="header-anchor" href="#增量分析常见问题" aria-hidden="true">#</a> 增量分析常见问题</h2><h3 id="缓存什么时候失效" tabindex="-1"><a class="header-anchor" href="#缓存什么时候失效" aria-hidden="true">#</a> 缓存什么时候失效</h3><p>以下几种原因会导致缓存失效：</p><p>​ PMD版本变更。不同版本创建的PMD缓存信息在不同的PMD版本之间可能不兼容。</p><p>​ 使用的规则集发生变化。规则集变化将导致缓存的失效，无论是增加删除或者修改跟着参数。</p>',14),i={href:"https://docs.pmd-code.org/latest/pmd_userdocs_cli_reference.html#auxclasspath",target:"_blank",rel:"noopener noreferrer"},l=e("code",null,"auxclasspath",-1),u=c('<p>​ 执行类路径(execution classpath)发生变化。执行类路径已更改。在执行类路径上，不仅包含 PMD 类，还包含例如以下内容的实现：自定义规则。如果执行类路径上的任何 jar 文件/类文件发生更改，则缓存也被视为无效。</p><h3 id="缓存了些什么内容" tabindex="-1"><a class="header-anchor" href="#缓存了些什么内容" aria-hidden="true">#</a> 缓存了些什么内容</h3><p>​ 缓存文件包含header和body两部分内容。header信息决定了该缓存信息是否有效。header有以下信息：</p><p>​ 📍PMD版本</p><p>​ 📍规则集检验数据(checksum)</p><p>​ 📍Auxclasspath校验数据(checksum)</p><p>​ 📍Execution classpath校验数据(checksum)</p><p>​ body包含了已经被分析过的文件入口。记录文件的一下信息：</p><p>​ 📍文件的绝对或者相对路径。</p><p>​ 📍文件自身的checksum。</p><p>​ 📍一条或者多条告警的相关信息。可以将缓存信息看成是一个Map，文件路径是Key，检测出的问题信息是value。</p>',11),_={href:"https://docs.pmd-code.org/apidocs/pmd-core/7.0.0-rc4/net/sourceforge/pmd/cache/FileAnalysisCache.html#",target:"_blank",rel:"noopener noreferrer"},m=e("code",null,"FileAnalysisCache",-1),x=c('<h3 id="pmd如何检查文件发生变化" tabindex="-1"><a class="header-anchor" href="#pmd如何检查文件发生变化" aria-hidden="true">#</a> PMD如何检查文件发生变化</h3><p>​ pmd在分析文件时会将文件的checksum缓存起来，和检测问题一起缓存。再次检测文件时会将缓存的checksum和重新计算的checksum进行对比。加入两个checksum相同，那么文件没有修改，不会执行规则检测，使用缓存的检测结果。如果两个checksum不同，那么之缓存的检测结果将会被丢弃，重新对文件进行检测。检测之后更新缓存信息。</p><h3 id="是否可以在分析分支b的时候使用分支a的缓存" tabindex="-1"><a class="header-anchor" href="#是否可以在分析分支b的时候使用分支a的缓存" aria-hidden="true">#</a> 是否可以在分析分支B的时候使用分支A的缓存</h3><p>​ 可以。但需要满足一些条件：</p><p>​ PMD的版本需要一致。</p><p>​ 规则集需要一致。</p><p>​ 项目依赖需要一致。不同的依赖会导致auxclasspath不一致，从而导致缓存不可用。</p><p>​ 文件名和存放位置不能变。因为pmd是根据文件名来缓存信息的。</p><p>​ 满足以上条件，不同分支的缓存可以共享。</p><h3 id="缓存是否可以在不同机器上使用" tabindex="-1"><a class="header-anchor" href="#缓存是否可以在不同机器上使用" aria-hidden="true">#</a> 缓存是否可以在不同机器上使用</h3><p>​ 只有在不同机器上项目文件放到同名的文件目录下。当然相同的PMD版本、相同的规则集、相同的auxclasspath、相同的执行classpath是基本前提条件。</p>',11);function f(b,k){const h=p("ExternalLinkIcon");return d(),t("div",null,[o,e("p",null,[a("​ "),e("a",i,[l,r(h)]),a("参数发生变化。因为在类型解析过程中使用到了auxclasspath。")]),u,e("p",null,[a("​ 缓存最终只是一个包含序列化数据（二进制）的文件。实现类 "),e("a",_,[m,r(h)]),a("负责解析处理。")]),x])}const D=s(n,[["render",f],["__file","7增量分析.html.vue"]]);export{D as default};
